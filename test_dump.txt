[CODE] '1 2 + print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:3@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 + print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:2: not enough items on stack for IntrinsicType.ADD: it expects two INTs on the stack
[NOTE] stack:
           0. INT@tmp.lang:1:0

[EXIT CODE] 1

[CODE] '1 2 +'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: stack is not empty: 1 items are unhandled
[NOTE] stack:
           0. INT@tmp.lang:1:4

[EXIT CODE] 1

[CODE] '? 1 ? 2 ? 3 ? 4 ? + ? + ? + ? print ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:0: Stack at compile time:
[NOTE] stack:
         (empty)
[INFO] tmp.lang:1:4: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
[INFO] tmp.lang:1:8: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:6
[INFO] tmp.lang:1:12: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:6
           2. INT@tmp.lang:1:10
[INFO] tmp.lang:1:16: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:6
           2. INT@tmp.lang:1:10
           3. INT@tmp.lang:1:14
[INFO] tmp.lang:1:20: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:6
           2. INT@tmp.lang:1:18
[INFO] tmp.lang:1:24: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:22
[INFO] tmp.lang:1:28: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:26
[INFO] tmp.lang:1:36: Stack at compile time:
[NOTE] stack:
         (empty)
[INFO] tmp.lang:1:0: Stack at runtime:
[NOTE] stack:
         (empty)
[INFO] tmp.lang:1:4: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
[INFO] tmp.lang:1:8: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
           1. INT:2@tmp.lang:1:6
[INFO] tmp.lang:1:12: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
           1. INT:2@tmp.lang:1:6
           2. INT:3@tmp.lang:1:10
[INFO] tmp.lang:1:16: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
           1. INT:2@tmp.lang:1:6
           2. INT:3@tmp.lang:1:10
           3. INT:4@tmp.lang:1:14
[INFO] tmp.lang:1:20: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
           1. INT:2@tmp.lang:1:6
           2. INT:7@tmp.lang:1:18
[INFO] tmp.lang:1:24: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:2
           1. INT:9@tmp.lang:1:22
[INFO] tmp.lang:1:28: Stack at runtime:
[NOTE] stack:
           0. INT:10@tmp.lang:1:26
[PRINT] INT:10@tmp.lang:1:26
[INFO] tmp.lang:1:36: Stack at runtime:
[NOTE] stack:
         (empty)

[EXIT CODE] 0

[CODE] '+'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.ADD: it expects two INTs on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] '~'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.BNOT: it expects one INT on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] '/%'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DIVMOD: it expects two INTs on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] '25 7 + print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:32@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 - print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:18@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 * print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:175@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 / print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:3@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '2 0 / print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:4: division by zero
[NOTE] a:
         INT:2@tmp.lang:1:0
[NOTE] b:
         INT:0@tmp.lang:1:2

[EXIT CODE] 1

[CODE] '25 7 % print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:4@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 /% ? print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:8: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:5
           1. INT@tmp.lang:1:5
[INFO] tmp.lang:1:8: Stack at runtime:
[NOTE] stack:
           0. INT:3@tmp.lang:1:5
           1. INT:4@tmp.lang:1:5
[PRINT] INT:4@tmp.lang:1:5
[PRINT] INT:3@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 << print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:3200@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 >> print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:0@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 | print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:31@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 & print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:1@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 7 ^ print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:30@tmp.lang:1:5

[EXIT CODE] 0

[CODE] '25 ~ print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:-26@tmp.lang:1:3

[EXIT CODE] 0

[CODE] 'true 5 + print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot add/subtract ValueType.BOOL and ValueType.INT
[NOTE] other_stack_items:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 * print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot multiply/divide ValueType.BOOL by ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 % print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot modulo ValueType.BOOL by ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 | print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot bitwise or/and/xor ValueType.BOOL with ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 << print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot shift ValueType.BOOL by ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 && print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot and/or ValueType.BOOL with ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 ! print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot not ValueType.INT
[NOTE] stack:
           0. BOOL@tmp.lang:1:0

[EXIT CODE] 1

[CODE] 'true 5 swap ~ print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:12: cannot bitwise not an ValueType.BOOL
[NOTE] stack:
           0. INT@tmp.lang:1:5

[EXIT CODE] 1

[CODE] 'true 5 == print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot compare ValueType.BOOL and ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true 5 < print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: cannot compare ValueType.BOOL and ValueType.INT
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'true false && print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:False@tmp.lang:1:11

[EXIT CODE] 0

[CODE] 'true false || print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:True@tmp.lang:1:11

[EXIT CODE] 0

[CODE] 'true ! print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:False@tmp.lang:1:5

[EXIT CODE] 0

[CODE] 'false ! print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:True@tmp.lang:1:6

[EXIT CODE] 0

[CODE] '1 2 == print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:False@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 != print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:True@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 < print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:True@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 > print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:False@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 <= print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:True@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 >= print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] BOOL:False@tmp.lang:1:4

[EXIT CODE] 0

[CODE] '1 2 ? print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:4: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:0
           1. INT@tmp.lang:1:2
[INFO] tmp.lang:1:4: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:0
           1. INT:2@tmp.lang:1:2
[PRINT] INT:2@tmp.lang:1:2
[PRINT] INT:1@tmp.lang:1:0

[EXIT CODE] 0

[CODE] '1 dup ? print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:6: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:0
           1. INT@tmp.lang:1:0
[INFO] tmp.lang:1:6: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:0
           1. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0

[EXIT CODE] 0

[CODE] '1 2 drop ? print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:9: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:0
[INFO] tmp.lang:1:9: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0

[EXIT CODE] 0

[CODE] '1 2 swap ? print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:9: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:0
[INFO] tmp.lang:1:9: Stack at runtime:
[NOTE] stack:
           0. INT:2@tmp.lang:1:2
           1. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:2@tmp.lang:1:2

[EXIT CODE] 0

[CODE] '1 2 3 ? print print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:6: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:0
           1. INT@tmp.lang:1:2
           2. INT@tmp.lang:1:4
[INFO] tmp.lang:1:6: Stack at runtime:
[NOTE] stack:
           0. INT:1@tmp.lang:1:0
           1. INT:2@tmp.lang:1:2
           2. INT:3@tmp.lang:1:4
[PRINT] INT:3@tmp.lang:1:4
[PRINT] INT:2@tmp.lang:1:2
[PRINT] INT:1@tmp.lang:1:0

[EXIT CODE] 0

[CODE] '1 2 3 rot ? print print print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:10: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:2
           1. INT@tmp.lang:1:4
           2. INT@tmp.lang:1:0
[INFO] tmp.lang:1:10: Stack at runtime:
[NOTE] stack:
           0. INT:2@tmp.lang:1:2
           1. INT:3@tmp.lang:1:4
           2. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:3@tmp.lang:1:4
[PRINT] INT:2@tmp.lang:1:2

[EXIT CODE] 0

[CODE] 'print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.PRINT: it expects one item on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] '?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:0: Stack at compile time:
[NOTE] stack:
         (empty)
[INFO] tmp.lang:1:0: Stack at runtime:
[NOTE] stack:
         (empty)

[EXIT CODE] 0

[CODE] 'dup'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DUP: it expects one item on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'swap'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.SWAP: it expects two items on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'drop'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DROP: it expects one item on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] 'rot'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.ROT: it expects three items on the stack
[NOTE] stack:
         (empty)

[EXIT CODE] 1

[CODE] '1 2 == if do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:10: condition part of InstructionType.IF should put exactly one BOOL on the stack
[NOTE] expected_stack:
           0. BOOL@tmp.lang:1:4
[NOTE] actual_stack:
         (empty)

[EXIT CODE] 1

[CODE] 'if 1 2 == do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:7@tmp.lang:1:20

[EXIT CODE] 0

[CODE] 'if 1 2 != do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:5@tmp.lang:1:13

[EXIT CODE] 0

[CODE] 'if 1 2 != do 5 else 7 8 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:24: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
           0. INT@tmp.lang:1:13
[NOTE] stack_else:
           0. INT@tmp.lang:1:20
           1. INT@tmp.lang:1:22

[EXIT CODE] 1

[CODE] 'if 1 2 != do 5 else 7 end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: stack is not empty: 1 items are unhandled
[NOTE] stack:
           0. INT@tmp.lang:1:20

[EXIT CODE] 1

[CODE] 'if 1 2 != do 5 else end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:20: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
           0. INT@tmp.lang:1:13
[NOTE] stack_else:
         (empty)

[EXIT CODE] 1

[CODE] 'if 1 2 != do 5 end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:15: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
           0. INT@tmp.lang:1:13
[NOTE] stack_else:
         (empty)

[EXIT CODE] 1

[CODE] 'if 1 2 != do 5 print end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:5@tmp.lang:1:13

[EXIT CODE] 0

[CODE] '5 if 1 2 == do drop 7 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:5@tmp.lang:1:0

[EXIT CODE] 0

[CODE] '5 if 1 2 != do drop 7 end print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:7@tmp.lang:1:20

[EXIT CODE] 0

[CODE] 'if'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
           0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=-1, ip3=-1, ip4=-1)

[EXIT CODE] 1

[CODE] 'if 1 2 == do'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
           0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=4, ip3=-1, ip4=-1)

[EXIT CODE] 1

[CODE] 'if 1 2 == do 5 print else'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
           0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=4, ip3=7, ip4=-1)

[EXIT CODE] 1

[CODE] 'if 1 2 == else 5 end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:17: if <cond> do <body> [else <body>] end

[EXIT CODE] 1

[CODE] 'if do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:3: not enough items on the stack for InstructionType.DO: it expects one BOOL on the stack

[EXIT CODE] 1

[CODE] 'if 1 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:5: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
         (empty)

[EXIT CODE] 1

[CODE] 'if 1 2 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:7: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
           0. INT@tmp.lang:1:3

[EXIT CODE] 1

[CODE] 'if 1 2 3 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:9: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
           0. INT@tmp.lang:1:3
           1. INT@tmp.lang:1:5

[EXIT CODE] 1

[CODE] 'if 1 2 3 == do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:12: condition part of InstructionType.IF should put exactly one BOOL on the stack
[NOTE] expected_stack:
         (empty)
[NOTE] actual_stack:
           0. INT@tmp.lang:1:3

[EXIT CODE] 1

[CODE] 'else'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: ELSE should follow an IF

[EXIT CODE] 1

[CODE] '10 while dup 5 > do 1 - print ? end drop'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:30: Stack at compile time:
[NOTE] stack:
         (empty)
[ERROR] tmp.lang:1:32: InstructionType.WHILE must not alter the stack state

[EXIT CODE] 1

[CODE] '10 while dup 5 > do 1 - dup print ? end drop'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[INFO] tmp.lang:1:34: Stack at compile time:
[NOTE] stack:
           0. INT@tmp.lang:1:22
[PRINT] INT:9@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
           0. INT:9@tmp.lang:1:22
[PRINT] INT:8@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
           0. INT:8@tmp.lang:1:22
[PRINT] INT:7@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
           0. INT:7@tmp.lang:1:22
[PRINT] INT:6@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
           0. INT:6@tmp.lang:1:22
[PRINT] INT:5@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
           0. INT:5@tmp.lang:1:22

[EXIT CODE] 0

[CODE] 'while else'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:6: ELSE should follow an IF, not InstructionType.WHILE

[EXIT CODE] 1

[CODE] 'while end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:6: while <cond> do <body> end

[EXIT CODE] 1

[CODE] 'while'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
           0. Block(type=<InstructionType.WHILE: 8>, ip1=0, ip2=-1, ip3=-1, ip4=-1)

[EXIT CODE] 1

[CODE] 'while 1 2 == do'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
           0. Block(type=<InstructionType.WHILE: 8>, ip1=0, ip2=4, ip3=-1, ip4=-1)

[EXIT CODE] 1

[CODE] 'while do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:6: not enough items on the stack for InstructionType.DO: it expects one BOOL on the stack

[EXIT CODE] 1

[CODE] 'while 1 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:8: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
         (empty)

[EXIT CODE] 1

[CODE] 'while 1 2 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:10: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
           0. INT@tmp.lang:1:6

[EXIT CODE] 1

[CODE] 'while 1 2 3 do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:12: InstructionType.DO expects one BOOL on the stack, but got ValueType.INT
[NOTE] other_stack_items:
           0. INT@tmp.lang:1:6
           1. INT@tmp.lang:1:8

[EXIT CODE] 1

[CODE] 'while 1 2 3 == do end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:15: condition part of InstructionType.WHILE should put exactly one BOOL on the stack
[NOTE] expected_stack:
         (empty)
[NOTE] actual_stack:
           0. INT@tmp.lang:1:6

[EXIT CODE] 1

[CODE] 'do'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: DO should follow an IF or WHILE

[EXIT CODE] 1

[CODE] 'end'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: END should follow an IF or WHILE

[EXIT CODE] 1

[CODE] ''
[CMD] py lang.py run tmp.lang
[EXIT CODE] 0

[CODE] "'"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: unterminated character literal

[EXIT CODE] 1

[CODE] "''"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: invalid character literal

[EXIT CODE] 1

[CODE] "'aa'"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: invalid character literal

[EXIT CODE] 1

[CODE] "'\\n'"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: invalid character literal

[EXIT CODE] 1

[CODE] "'\\t'"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: invalid character literal

[EXIT CODE] 1

[CODE] "'\\''"
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:1: unterminated character literal

[EXIT CODE] 1

[CODE] '"'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: unterminated string literal

[EXIT CODE] 1

[CODE] '"" ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not implemented: string literals

[EXIT CODE] 1

[CODE] '"abc" ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not implemented: string literals

[EXIT CODE] 1

[CODE] '"abc\\n" ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not implemented: string literals

[EXIT CODE] 1

[CODE] '"abc\'" ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: not implemented: string literals

[EXIT CODE] 1

[CODE] '"abc\\"" ?'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:1: unterminated string literal

[EXIT CODE] 1

[CODE] '1 // comment \n print'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[PRINT] INT:1@tmp.lang:1:0

[EXIT CODE] 0

[CODE] 'proc'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: arbitrary word handling is not implemented yet: proc

[EXIT CODE] 1

[CODE] 'somerandomword'
[CMD] py lang.py run tmp.lang
[STDOUT]:
[ERROR] tmp.lang:1:0: arbitrary word handling is not implemented yet: somerandomword

[EXIT CODE] 1

