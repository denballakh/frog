============================================================
[CODE] '1 2 + print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:3@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 + print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:2: not enough items on stack for IntrinsicType.ADD: it expects two INTs on the stack
[NOTE] stack:
      0. INT@tmp.lang:1:0
[EXIT CODE] 1

============================================================
[CODE] '1 2 +'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: return type mismatch: expected 0 items on the stack, got 1
[NOTE] stack:
      0. INT@tmp.lang:1:4
[NOTE] outs: (empty)
[EXIT CODE] 1

============================================================
[CODE] '? 1 ? 2 ? 3 ? 4 ? + ? + ? + ? print ?'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:0: Stack at compile time:
[NOTE] stack: (empty)
[INFO] tmp.lang:1:4: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
[INFO] tmp.lang:1:8: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:6
[INFO] tmp.lang:1:12: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:6
      2. INT@tmp.lang:1:10
[INFO] tmp.lang:1:16: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:6
      2. INT@tmp.lang:1:10
      3. INT@tmp.lang:1:14
[INFO] tmp.lang:1:20: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:6
      2. INT@tmp.lang:1:18
[INFO] tmp.lang:1:24: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:22
[INFO] tmp.lang:1:28: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:26
[INFO] tmp.lang:1:36: Stack at compile time:
[NOTE] stack: (empty)
[INFO] tmp.lang:1:0: Stack at runtime:
[NOTE] stack: (empty)
[INFO] tmp.lang:1:4: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
[INFO] tmp.lang:1:8: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
      1. INT:2@tmp.lang:1:6
[INFO] tmp.lang:1:12: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
      1. INT:2@tmp.lang:1:6
      2. INT:3@tmp.lang:1:10
[INFO] tmp.lang:1:16: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
      1. INT:2@tmp.lang:1:6
      2. INT:3@tmp.lang:1:10
      3. INT:4@tmp.lang:1:14
[INFO] tmp.lang:1:20: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
      1. INT:2@tmp.lang:1:6
      2. INT:7@tmp.lang:1:18
[INFO] tmp.lang:1:24: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:2
      1. INT:9@tmp.lang:1:22
[INFO] tmp.lang:1:28: Stack at runtime:
[NOTE] stack:
      0. INT:10@tmp.lang:1:26
[PRINT] INT:10@tmp.lang:1:26
[INFO] tmp.lang:1:36: Stack at runtime:
[NOTE] stack: (empty)
[EXIT CODE] 0

============================================================
[CODE] '+'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.ADD: it expects two INTs on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] '~'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.BNOT: it expects one INT on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] '/%'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DIVMOD: it expects two INTs on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] '25 7 + print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:32@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 - print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:18@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 * print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:175@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 / print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:3@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '2 0 / print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:4: division by zero
[NOTE] a: INT:2@tmp.lang:1:0
[NOTE] b: INT:0@tmp.lang:1:2
[EXIT CODE] 1

============================================================
[CODE] '25 7 % print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:4@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 /% ? print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:8: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:5
      1. INT@tmp.lang:1:5
[INFO] tmp.lang:1:8: Stack at runtime:
[NOTE] stack:
      0. INT:3@tmp.lang:1:5
      1. INT:4@tmp.lang:1:5
[PRINT] INT:4@tmp.lang:1:5
[PRINT] INT:3@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 << print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:3200@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 >> print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:0@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 | print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:31@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 & print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:1@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 7 ^ print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:30@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] '25 ~ print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:-26@tmp.lang:1:3
[EXIT CODE] 0

============================================================
[CODE] 'true 5 + print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot add/subtract BOOL and INT
[NOTE] other_stack_items: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 * print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot multiply/divide BOOL by INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 % print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot modulo BOOL by INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 | print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot bitwise or/and/xor BOOL with INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 << print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot shift BOOL by INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 && print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot and/or BOOL with INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 ! print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot not INT
[NOTE] stack:
      0. BOOL@tmp.lang:1:0
[EXIT CODE] 1

============================================================
[CODE] 'true 5 swap ~ print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:12: cannot bitwise not an BOOL
[NOTE] stack:
      0. INT@tmp.lang:1:5
[EXIT CODE] 1

============================================================
[CODE] 'true 5 == print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot compare BOOL and INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true 5 < print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: cannot compare BOOL and INT
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'true false && print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:False@tmp.lang:1:11
[EXIT CODE] 0

============================================================
[CODE] 'true false || print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:True@tmp.lang:1:11
[EXIT CODE] 0

============================================================
[CODE] 'true ! print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:False@tmp.lang:1:5
[EXIT CODE] 0

============================================================
[CODE] 'false ! print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:True@tmp.lang:1:6
[EXIT CODE] 0

============================================================
[CODE] '1 2 == print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:False@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 != print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:True@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 < print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:True@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 > print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:False@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 <= print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:True@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 >= print'
[CMD] py lang.py run tmp.lang
[PRINT] BOOL:False@tmp.lang:1:4
[EXIT CODE] 0

============================================================
[CODE] '1 2 ? print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:4: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:0
      1. INT@tmp.lang:1:2
[INFO] tmp.lang:1:4: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:0
      1. INT:2@tmp.lang:1:2
[PRINT] INT:2@tmp.lang:1:2
[PRINT] INT:1@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] '1 dup ? print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:6: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:0
      1. INT@tmp.lang:1:0
[INFO] tmp.lang:1:6: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:0
      1. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] '1 2 drop ? print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:9: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:0
[INFO] tmp.lang:1:9: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] '1 2 swap ? print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:9: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:0
[INFO] tmp.lang:1:9: Stack at runtime:
[NOTE] stack:
      0. INT:2@tmp.lang:1:2
      1. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:2@tmp.lang:1:2
[EXIT CODE] 0

============================================================
[CODE] '1 2 3 ? print print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:6: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:0
      1. INT@tmp.lang:1:2
      2. INT@tmp.lang:1:4
[INFO] tmp.lang:1:6: Stack at runtime:
[NOTE] stack:
      0. INT:1@tmp.lang:1:0
      1. INT:2@tmp.lang:1:2
      2. INT:3@tmp.lang:1:4
[PRINT] INT:3@tmp.lang:1:4
[PRINT] INT:2@tmp.lang:1:2
[PRINT] INT:1@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] '1 2 3 rot ? print print print'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:10: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:2
      1. INT@tmp.lang:1:4
      2. INT@tmp.lang:1:0
[INFO] tmp.lang:1:10: Stack at runtime:
[NOTE] stack:
      0. INT:2@tmp.lang:1:2
      1. INT:3@tmp.lang:1:4
      2. INT:1@tmp.lang:1:0
[PRINT] INT:1@tmp.lang:1:0
[PRINT] INT:3@tmp.lang:1:4
[PRINT] INT:2@tmp.lang:1:2
[EXIT CODE] 0

============================================================
[CODE] 'print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.PRINT: it expects one item on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] '?'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:0: Stack at compile time:
[NOTE] stack: (empty)
[INFO] tmp.lang:1:0: Stack at runtime:
[NOTE] stack: (empty)
[EXIT CODE] 0

============================================================
[CODE] 'dup'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DUP: it expects one item on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'swap'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.SWAP: it expects two items on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'drop'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.DROP: it expects one item on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'rot'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not enough items on stack for IntrinsicType.ROT: it expects three items on the stack
[NOTE] stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] '1 2 == if do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:10: condition part of InstructionType.IF should put exactly one BOOL on the stack
[NOTE] expected_stack:
      0. BOOL@tmp.lang:1:4
[NOTE] actual_stack: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 == do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:7@tmp.lang:1:20
[EXIT CODE] 0

============================================================
[CODE] 'if 1 2 != do 5 else 7 end print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:5@tmp.lang:1:13
[EXIT CODE] 0

============================================================
[CODE] 'if 1 2 != do 5 else 7 8 end print'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:24: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
      0. INT@tmp.lang:1:13
[NOTE] stack_else:
      0. INT@tmp.lang:1:20
      1. INT@tmp.lang:1:22
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 != do 5 else 7 end'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: return type mismatch: expected 0 items on the stack, got 1
[NOTE] stack:
      0. INT@tmp.lang:1:20
[NOTE] outs: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 != do 5 else end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:20: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
      0. INT@tmp.lang:1:13
[NOTE] stack_else: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 != do 5 end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:15: both branches of InstructionType.IF must leave the stack in the same state
[NOTE] stack_then:
      0. INT@tmp.lang:1:13
[NOTE] stack_else: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 != do 5 print end'
[CMD] py lang.py run tmp.lang
[PRINT] INT:5@tmp.lang:1:13
[EXIT CODE] 0

============================================================
[CODE] '5 if 1 2 == do drop 7 end print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:5@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] '5 if 1 2 != do drop 7 end print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:7@tmp.lang:1:20
[EXIT CODE] 0

============================================================
[CODE] 'if'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
      0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=-1, ip3=-1, ip4=-1)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 == do'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
      0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=4, ip3=-1, ip4=-1)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 == do 5 print else'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
      0. Block(type=<InstructionType.IF: 6>, ip1=0, ip2=4, ip3=7, ip4=-1)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 == else 5 end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:17: if <cond> do <body> [else <body>] end
[EXIT CODE] 1

============================================================
[CODE] 'if do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:3: not enough items on the stack for InstructionType.DO: it expects one BOOL on the stack
[EXIT CODE] 1

============================================================
[CODE] 'if 1 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:5: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:7: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items:
      0. INT@tmp.lang:1:3
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 3 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:9: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items:
      0. INT@tmp.lang:1:3
      1. INT@tmp.lang:1:5
[EXIT CODE] 1

============================================================
[CODE] 'if 1 2 3 == do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:12: condition part of InstructionType.IF should put exactly one BOOL on the stack
[NOTE] expected_stack: (empty)
[NOTE] actual_stack:
      0. INT@tmp.lang:1:3
[EXIT CODE] 1

============================================================
[CODE] 'else'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: ELSE should follow an IF
[EXIT CODE] 1

============================================================
[CODE] '10 while dup 5 > do 1 - print ? end drop'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:30: Stack at compile time:
[NOTE] stack: (empty)
[ERROR] tmp.lang:1:32: InstructionType.WHILE must not alter the stack state
[EXIT CODE] 1

============================================================
[CODE] '10 while dup 5 > do 1 - dup print ? end drop'
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:1:34: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:1:22
[PRINT] INT:9@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
      0. INT:9@tmp.lang:1:22
[PRINT] INT:8@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
      0. INT:8@tmp.lang:1:22
[PRINT] INT:7@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
      0. INT:7@tmp.lang:1:22
[PRINT] INT:6@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
      0. INT:6@tmp.lang:1:22
[PRINT] INT:5@tmp.lang:1:22
[INFO] tmp.lang:1:34: Stack at runtime:
[NOTE] stack:
      0. INT:5@tmp.lang:1:22
[EXIT CODE] 0

============================================================
[CODE] 'while else'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:6: ELSE should follow an IF, not WHILE
[EXIT CODE] 1

============================================================
[CODE] 'while end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:6: while <cond> do <body> end
[EXIT CODE] 1

============================================================
[CODE] 'while'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
      0. Block(type=<InstructionType.WHILE: 8>, ip1=0, ip2=-1, ip3=-1, ip4=-1)
[EXIT CODE] 1

============================================================
[CODE] 'while 1 2 == do'
[CMD] py lang.py run tmp.lang
[ERROR] <?>:0:0: unclosed blocks
[NOTE] blocks:
      0. Block(type=<InstructionType.WHILE: 8>, ip1=0, ip2=4, ip3=-1, ip4=-1)
[EXIT CODE] 1

============================================================
[CODE] 'while do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:6: not enough items on the stack for InstructionType.DO: it expects one BOOL on the stack
[EXIT CODE] 1

============================================================
[CODE] 'while 1 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:8: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items: (empty)
[EXIT CODE] 1

============================================================
[CODE] 'while 1 2 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:10: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items:
      0. INT@tmp.lang:1:6
[EXIT CODE] 1

============================================================
[CODE] 'while 1 2 3 do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:12: InstructionType.DO expects one BOOL on the stack, but got INT
[NOTE] other_stack_items:
      0. INT@tmp.lang:1:6
      1. INT@tmp.lang:1:8
[EXIT CODE] 1

============================================================
[CODE] 'while 1 2 3 == do end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:15: condition part of InstructionType.WHILE should put exactly one BOOL on the stack
[NOTE] expected_stack: (empty)
[NOTE] actual_stack:
      0. INT@tmp.lang:1:6
[EXIT CODE] 1

============================================================
[CODE] 'do'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: DO should follow an IF or WHILE
[EXIT CODE] 1

============================================================
[CODE] 'end'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: END should follow an IF or WHILE
[EXIT CODE] 1

============================================================
[CODE] ''
[CMD] py lang.py run tmp.lang
[EXIT CODE] 0

============================================================
[CODE] "'"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: unterminated character literal
[EXIT CODE] 1

============================================================
[CODE] "''"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: invalid character literal
[EXIT CODE] 1

============================================================
[CODE] "'aa'"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: invalid character literal
[EXIT CODE] 1

============================================================
[CODE] "'\\n'"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: invalid character literal
[EXIT CODE] 1

============================================================
[CODE] "'\\t'"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: invalid character literal
[EXIT CODE] 1

============================================================
[CODE] "'\\''"
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:1: unterminated character literal
[EXIT CODE] 1

============================================================
[CODE] '"'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: unterminated string literal
[EXIT CODE] 1

============================================================
[CODE] '"" ?'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not implemented: string literals
[EXIT CODE] 1

============================================================
[CODE] '"abc" ?'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not implemented: string literals
[EXIT CODE] 1

============================================================
[CODE] '"abc\\n" ?'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not implemented: string literals
[EXIT CODE] 1

============================================================
[CODE] '"abc\'" ?'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: not implemented: string literals
[EXIT CODE] 1

============================================================
[CODE] '"abc\\"" ?'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:1: unterminated string literal
[EXIT CODE] 1

============================================================
[CODE] '1 // comment \n print'
[CMD] py lang.py run tmp.lang
[PRINT] INT:1@tmp.lang:1:0
[EXIT CODE] 0

============================================================
[CODE] 'proc'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: expected a name after PROC
[EXIT CODE] 1

============================================================
[CODE] 'somerandomword'
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:1:0: unknown word somerandomword
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a int -- int do 2 * end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[PRINT] INT:10@tmp.lang:2:27
[EXIT CODE] 0

============================================================
[CODE] '\n    proc a do 2 * end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:2:9: expected a KeywordType.TYPE_DELIM after proc args, got Token(type=<TokenType.KEYWORD: 6>, value=<KeywordType.DO: 5>, loc=tmp.lang:2:11)
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a -- do 2 * end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:2:19: not enough items on stack for IntrinsicType.MUL: it expects two INTs on the stack
[NOTE] other_stack_items:
      0. INT@tmp.lang:2:17
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a int -- do 2 * end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:2:25: return type mismatch: expected 0 items on the stack, got 1
[NOTE] stack:
      0. INT@tmp.lang:2:23
[NOTE] outs: (empty)
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a int -- int int do 2 * end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:2:33: return type mismatch: expected 2 items on the stack, got 1
[NOTE] stack:
      0. INT@tmp.lang:2:31
[NOTE] outs:
      0. INT
      1. INT
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a bool -- int do drop 5 end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:3:22: stack doesnt match at 0 for a: expected INT but got BOOL
[NOTE] stack:
      0. INT@tmp.lang:3:20
[NOTE] ins:
      0. BOOL
[EXIT CODE] 1

============================================================
[CODE] '\n    proc a int int -- int do + end\n    proc main -- do 5 a print end\n    '
[CMD] py lang.py run tmp.lang
[ERROR] tmp.lang:3:22: stack too small for a: expected 2 but got 1
[NOTE] stack:
      0. INT@tmp.lang:3:20
[NOTE] ins:
      0. INT
      1. INT
[EXIT CODE] 1

============================================================
[CODE] '\n    proc inc int -- int do 1 + end\n    proc dec int -- int do 1 - end\n    proc good int -- bool do 5 > end\n    proc show int -- int do ? dup print end\n\n    proc main -- do\n        10\n        while dup good do\n          dec\n          show\n        end\n        drop\n    end\n    '
[CMD] py lang.py run tmp.lang
[INFO] tmp.lang:5:28: Stack at compile time:
[NOTE] stack:
      0. INT@tmp.lang:5:14
[INFO] tmp.lang:5:28: Stack at runtime:
[NOTE] stack:
      0. INT:9@tmp.lang:3:29
[PRINT] INT:9@tmp.lang:3:29
[INFO] tmp.lang:5:28: Stack at runtime:
[NOTE] stack:
      0. INT:8@tmp.lang:3:29
[PRINT] INT:8@tmp.lang:3:29
[INFO] tmp.lang:5:28: Stack at runtime:
[NOTE] stack:
      0. INT:7@tmp.lang:3:29
[PRINT] INT:7@tmp.lang:3:29
[INFO] tmp.lang:5:28: Stack at runtime:
[NOTE] stack:
      0. INT:6@tmp.lang:3:29
[PRINT] INT:6@tmp.lang:3:29
[INFO] tmp.lang:5:28: Stack at runtime:
[NOTE] stack:
      0. INT:5@tmp.lang:3:29
[PRINT] INT:5@tmp.lang:3:29
[EXIT CODE] 0

============================================================
[CODE] '\n    proc dec int -- int do 1 - end\n    proc fib_step int int -- int int do dup rot + end\n    proc main -- do\n        0 1 15\n        while dup 0 > do\n          rot rot\n          dup print\n          fib_step\n          rot\n          dec\n        end\n        drop drop drop\n    end\n    '
[CMD] py lang.py run tmp.lang
[PRINT] INT:1@tmp.lang:5:10
[PRINT] INT:1@tmp.lang:3:48
[PRINT] INT:2@tmp.lang:3:48
[PRINT] INT:3@tmp.lang:3:48
[PRINT] INT:5@tmp.lang:3:48
[PRINT] INT:8@tmp.lang:3:48
[PRINT] INT:13@tmp.lang:3:48
[PRINT] INT:21@tmp.lang:3:48
[PRINT] INT:34@tmp.lang:3:48
[PRINT] INT:55@tmp.lang:3:48
[PRINT] INT:89@tmp.lang:3:48
[PRINT] INT:144@tmp.lang:3:48
[PRINT] INT:233@tmp.lang:3:48
[PRINT] INT:377@tmp.lang:3:48
[PRINT] INT:610@tmp.lang:3:48
[EXIT CODE] 0

============================================================
[CMD] py lang.py
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
[ERROR] no subcommand specified

[EXIT CODE] 2
============================================================
[CMD] py lang.py -h
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
Options:
  -h --help                   print this help message
  -l <level>                  log level: ERROR,WARN,INFO,TRACE
Subcommands:
  run FILE                  interpret
    FILE                      a file to interpret
    OPTIONS:
  build [OPTIONS] FILE      build
    FILE                      a file to build
    OPTIONS:
      -o FILE                 where to put built binary
      -r                      also run the binary
  repl                      start a Read-Eval-Print-Loop

[EXIT CODE] 0
============================================================
[CMD] py lang.py --help
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
Options:
  -h --help                   print this help message
  -l <level>                  log level: ERROR,WARN,INFO,TRACE
Subcommands:
  run FILE                  interpret
    FILE                      a file to interpret
    OPTIONS:
  build [OPTIONS] FILE      build
    FILE                      a file to build
    OPTIONS:
      -o FILE                 where to put built binary
      -r                      also run the binary
  repl                      start a Read-Eval-Print-Loop

[EXIT CODE] 0
============================================================
[CMD] py lang.py run
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
[ERROR] no file specified

[EXIT CODE] 2
============================================================
[CMD] py lang.py run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
[ERROR] no log level specified

[EXIT CODE] 2
============================================================
[CMD] py lang.py -l TRACE run
[STDOUT]:
Usage: py lang.py [OPTIONS] SUBCOMMAND <ARGS>
[ERROR] no file specified

[EXIT CODE] 2
============================================================
[CMD] py lang.py -l TRACE run xxx
[STDERR]:
Traceback (most recent call last):
  File "/mnt/d/GitHub/lang/lang.py", line 2511, in <module>
    main(sys.argv[1:])
    ~~~~^^^^^^^^^^^^^^
  File "/mnt/d/GitHub/lang/lang.py", line 2427, in main
    with open(filename, 'rt') as f:
         ~~~~^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'xxx'

[EXIT CODE] 1
============================================================
[CMD] py lang.py -l TRACE run p1.lang
[STDOUT]:
[TRACE] <?>:0:0: file: p1.lang
[NOTE] Tokens:
      0. p1.lang:5:0:KEYWORD:IF
      1. p1.lang:6:2:INT:1
      2. p1.lang:6:4:INT:2
      3. p1.lang:6:6:WORD:'=='
      4. p1.lang:7:0:KEYWORD:DO
      5. p1.lang:8:2:INT:11
      6. p1.lang:8:5:INT:2
      7. p1.lang:8:7:WORD:'*'
      8. p1.lang:9:0:KEYWORD:ELSE
      9. p1.lang:10:2:INT:12
     10. p1.lang:10:5:INT:2
     11. p1.lang:10:7:WORD:'*'
     12. p1.lang:11:0:KEYWORD:END
     13. p1.lang:12:0:WORD:'print'
     14. p1.lang:14:0:INT:10
     15. p1.lang:15:0:KEYWORD:WHILE
     16. p1.lang:16:2:WORD:'dup'
     17. p1.lang:16:6:INT:5
     18. p1.lang:16:8:WORD:'>'
     19. p1.lang:17:0:KEYWORD:DO
     20. p1.lang:18:2:WORD:'dup'
     21. p1.lang:18:6:WORD:'print'
     22. p1.lang:19:2:INT:1
     23. p1.lang:19:4:WORD:'-'
     24. p1.lang:20:0:KEYWORD:END
     25. p1.lang:21:0:WORD:'drop'
     26. p1.lang:25:0:INT:10
     27. p1.lang:25:3:KEYWORD:WHILE
     28. p1.lang:25:12:WORD:'dup'
     29. p1.lang:25:16:INT:5
     30. p1.lang:25:18:WORD:'>'
     31. p1.lang:25:20:KEYWORD:DO
     32. p1.lang:25:25:WORD:'dup'
     33. p1.lang:25:29:WORD:'print'
     34. p1.lang:25:37:INT:1
     35. p1.lang:25:39:WORD:'-'
     36. p1.lang:25:41:KEYWORD:END
     37. p1.lang:25:45:WORD:'drop'
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc main:
      0. IF
      1. PUSH_INT:1
      2. PUSH_INT:2
      3. INTRINSIC:EQ
      4. DO:8
      5. PUSH_INT:11
      6. PUSH_INT:2
      7. INTRINSIC:MUL
      8. ELSE:12
      9. PUSH_INT:12
     10. PUSH_INT:2
     11. INTRINSIC:MUL
     12. END:13
     13. INTRINSIC:PRINT
     14. PUSH_INT:10
     15. WHILE
     16. INTRINSIC:DUP
     17. PUSH_INT:5
     18. INTRINSIC:GT
     19. DO:24
     20. INTRINSIC:DUP
     21. INTRINSIC:PRINT
     22. PUSH_INT:1
     23. INTRINSIC:SUB
     24. END:15
     25. INTRINSIC:DROP
     26. PUSH_INT:10
     27. WHILE
     28. INTRINSIC:DUP
     29. PUSH_INT:5
     30. INTRINSIC:GT
     31. DO:36
     32. INTRINSIC:DUP
     33. INTRINSIC:PRINT
     34. PUSH_INT:1
     35. INTRINSIC:SUB
     36. END:27
     37. INTRINSIC:DROP
     38. RET
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l LOL run p1.lang
[STDOUT]:
[ERROR] <cli>:1:0: invalid log level: LOL, expected one of ['ERROR', 'WARN', 'INFO', 'TRACE', 'DEFAULT']

[EXIT CODE] 1
============================================================
[CMD] py lang.py -l WARN run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l INFO run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l ERROR run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l DEFAULT run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE run p1.lang
[STDOUT]:
[TRACE] <?>:0:0: file: p1.lang
[NOTE] Tokens:
      0. p1.lang:5:0:KEYWORD:IF
      1. p1.lang:6:2:INT:1
      2. p1.lang:6:4:INT:2
      3. p1.lang:6:6:WORD:'=='
      4. p1.lang:7:0:KEYWORD:DO
      5. p1.lang:8:2:INT:11
      6. p1.lang:8:5:INT:2
      7. p1.lang:8:7:WORD:'*'
      8. p1.lang:9:0:KEYWORD:ELSE
      9. p1.lang:10:2:INT:12
     10. p1.lang:10:5:INT:2
     11. p1.lang:10:7:WORD:'*'
     12. p1.lang:11:0:KEYWORD:END
     13. p1.lang:12:0:WORD:'print'
     14. p1.lang:14:0:INT:10
     15. p1.lang:15:0:KEYWORD:WHILE
     16. p1.lang:16:2:WORD:'dup'
     17. p1.lang:16:6:INT:5
     18. p1.lang:16:8:WORD:'>'
     19. p1.lang:17:0:KEYWORD:DO
     20. p1.lang:18:2:WORD:'dup'
     21. p1.lang:18:6:WORD:'print'
     22. p1.lang:19:2:INT:1
     23. p1.lang:19:4:WORD:'-'
     24. p1.lang:20:0:KEYWORD:END
     25. p1.lang:21:0:WORD:'drop'
     26. p1.lang:25:0:INT:10
     27. p1.lang:25:3:KEYWORD:WHILE
     28. p1.lang:25:12:WORD:'dup'
     29. p1.lang:25:16:INT:5
     30. p1.lang:25:18:WORD:'>'
     31. p1.lang:25:20:KEYWORD:DO
     32. p1.lang:25:25:WORD:'dup'
     33. p1.lang:25:29:WORD:'print'
     34. p1.lang:25:37:INT:1
     35. p1.lang:25:39:WORD:'-'
     36. p1.lang:25:41:KEYWORD:END
     37. p1.lang:25:45:WORD:'drop'
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc main:
      0. IF
      1. PUSH_INT:1
      2. PUSH_INT:2
      3. INTRINSIC:EQ
      4. DO:8
      5. PUSH_INT:11
      6. PUSH_INT:2
      7. INTRINSIC:MUL
      8. ELSE:12
      9. PUSH_INT:12
     10. PUSH_INT:2
     11. INTRINSIC:MUL
     12. END:13
     13. INTRINSIC:PRINT
     14. PUSH_INT:10
     15. WHILE
     16. INTRINSIC:DUP
     17. PUSH_INT:5
     18. INTRINSIC:GT
     19. DO:24
     20. INTRINSIC:DUP
     21. INTRINSIC:PRINT
     22. PUSH_INT:1
     23. INTRINSIC:SUB
     24. END:15
     25. INTRINSIC:DROP
     26. PUSH_INT:10
     27. WHILE
     28. INTRINSIC:DUP
     29. PUSH_INT:5
     30. INTRINSIC:GT
     31. DO:36
     32. INTRINSIC:DUP
     33. INTRINSIC:PRINT
     34. PUSH_INT:1
     35. INTRINSIC:SUB
     36. END:27
     37. INTRINSIC:DROP
     38. RET
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE run p2.lang
[STDOUT]:
[TRACE] <?>:0:0: file: p2.lang
[NOTE] Tokens:
      0. p2.lang:2:0:INT:1
      1. p2.lang:3:0:INT:2
      2. p2.lang:4:0:WORD:'swap'
      3. p2.lang:5:0:WORD:'dup'
      4. p2.lang:6:0:WORD:'print'
      5. p2.lang:7:0:INT:10
      6. p2.lang:8:0:WORD:'*'
      7. p2.lang:9:0:WORD:'+'
      8. p2.lang:10:0:KEYWORD:WHILE
      9. p2.lang:11:2:WORD:'dup'
     10. p2.lang:12:2:INT:3
     11. p2.lang:13:2:WORD:'>'
     12. p2.lang:14:0:KEYWORD:DO
     13. p2.lang:15:2:KEYWORD:IF
     14. p2.lang:16:4:WORD:'dup'
     15. p2.lang:17:4:INT:2
     16. p2.lang:18:4:WORD:'%'
     17. p2.lang:19:4:INT:0
     18. p2.lang:20:4:WORD:'=='
     19. p2.lang:21:2:KEYWORD:DO
     20. p2.lang:22:4:INT:5
     21. p2.lang:23:2:KEYWORD:ELSE
     22. p2.lang:24:4:INT:7
     23. p2.lang:25:2:KEYWORD:END
     24. p2.lang:27:2:WORD:'print'
     25. p2.lang:28:2:INT:1
     26. p2.lang:29:2:WORD:'-'
     27. p2.lang:30:0:KEYWORD:END
     28. p2.lang:32:0:WORD:'drop'
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc main:
      0. PUSH_INT:1
      1. PUSH_INT:2
      2. INTRINSIC:SWAP
      3. INTRINSIC:DUP
      4. INTRINSIC:PRINT
      5. PUSH_INT:10
      6. INTRINSIC:MUL
      7. INTRINSIC:ADD
      8. WHILE
      9. INTRINSIC:DUP
     10. PUSH_INT:3
     11. INTRINSIC:GT
     12. DO:27
     13. IF
     14. INTRINSIC:DUP
     15. PUSH_INT:2
     16. INTRINSIC:MOD
     17. PUSH_INT:0
     18. INTRINSIC:EQ
     19. DO:21
     20. PUSH_INT:5
     21. ELSE:23
     22. PUSH_INT:7
     23. END:24
     24. INTRINSIC:PRINT
     25. PUSH_INT:1
     26. INTRINSIC:SUB
     27. END:8
     28. INTRINSIC:DROP
     29. RET
[PRINT] INT:1@p2.lang:2:0
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE run procs.lang
[STDOUT]:
[TRACE] <?>:0:0: file: procs.lang
[NOTE] Tokens:
      0. procs.lang:1:0:KEYWORD:PROC
      1. procs.lang:1:5:WORD:'a'
      2. procs.lang:1:7:WORD:'int'
      3. procs.lang:1:11:KEYWORD:TYPE_DELIM
      4. procs.lang:1:14:WORD:'int'
      5. procs.lang:1:18:KEYWORD:DO
      6. procs.lang:2:4:WORD:'?'
      7. procs.lang:3:4:INT:2
      8. procs.lang:4:4:WORD:'?'
      9. procs.lang:5:4:WORD:'*'
     10. procs.lang:6:4:WORD:'?'
     11. procs.lang:7:0:KEYWORD:END
     12. procs.lang:9:0:KEYWORD:PROC
     13. procs.lang:9:5:WORD:'main'
     14. procs.lang:9:10:KEYWORD:TYPE_DELIM
     15. procs.lang:9:13:KEYWORD:DO
     16. procs.lang:10:4:WORD:'?'
     17. procs.lang:11:4:INT:5
     18. procs.lang:12:4:WORD:'?'
     19. procs.lang:13:4:WORD:'a'
     20. procs.lang:14:4:WORD:'?'
     21. procs.lang:15:4:WORD:'print'
     22. procs.lang:16:4:WORD:'?'
     23. procs.lang:17:0:KEYWORD:END
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc a:
      0. INTRINSIC:DEBUG
      1. PUSH_INT:2
      2. INTRINSIC:DEBUG
      3. INTRINSIC:MUL
      4. INTRINSIC:DEBUG
      5. RET
    proc main:
      0. INTRINSIC:DEBUG
      1. PUSH_INT:5
      2. INTRINSIC:DEBUG
      3. WORD:'a'
      4. INTRINSIC:DEBUG
      5. INTRINSIC:PRINT
      6. INTRINSIC:DEBUG
      7. RET
[INFO] procs.lang:2:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
[INFO] procs.lang:4:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
      1. INT@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:5:4
[INFO] procs.lang:10:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:11:4
[INFO] procs.lang:14:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:13:4
[INFO] procs.lang:16:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:10:4: Stack at runtime:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
[INFO] procs.lang:2:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
[INFO] procs.lang:4:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
      1. INT:2@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at runtime:
[NOTE] stack:
      0. INT:10@procs.lang:5:4
[INFO] procs.lang:14:4: Stack at runtime:
[NOTE] stack:
      0. INT:10@procs.lang:5:4
[PRINT] INT:10@procs.lang:5:4
[INFO] procs.lang:16:4: Stack at runtime:
[NOTE] stack: (empty)

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE build p1.lang
[STDOUT]:
[TRACE] <?>:0:0: file: p1.lang
[NOTE] Tokens:
      0. p1.lang:5:0:KEYWORD:IF
      1. p1.lang:6:2:INT:1
      2. p1.lang:6:4:INT:2
      3. p1.lang:6:6:WORD:'=='
      4. p1.lang:7:0:KEYWORD:DO
      5. p1.lang:8:2:INT:11
      6. p1.lang:8:5:INT:2
      7. p1.lang:8:7:WORD:'*'
      8. p1.lang:9:0:KEYWORD:ELSE
      9. p1.lang:10:2:INT:12
     10. p1.lang:10:5:INT:2
     11. p1.lang:10:7:WORD:'*'
     12. p1.lang:11:0:KEYWORD:END
     13. p1.lang:12:0:WORD:'print'
     14. p1.lang:14:0:INT:10
     15. p1.lang:15:0:KEYWORD:WHILE
     16. p1.lang:16:2:WORD:'dup'
     17. p1.lang:16:6:INT:5
     18. p1.lang:16:8:WORD:'>'
     19. p1.lang:17:0:KEYWORD:DO
     20. p1.lang:18:2:WORD:'dup'
     21. p1.lang:18:6:WORD:'print'
     22. p1.lang:19:2:INT:1
     23. p1.lang:19:4:WORD:'-'
     24. p1.lang:20:0:KEYWORD:END
     25. p1.lang:21:0:WORD:'drop'
     26. p1.lang:25:0:INT:10
     27. p1.lang:25:3:KEYWORD:WHILE
     28. p1.lang:25:12:WORD:'dup'
     29. p1.lang:25:16:INT:5
     30. p1.lang:25:18:WORD:'>'
     31. p1.lang:25:20:KEYWORD:DO
     32. p1.lang:25:25:WORD:'dup'
     33. p1.lang:25:29:WORD:'print'
     34. p1.lang:25:37:INT:1
     35. p1.lang:25:39:WORD:'-'
     36. p1.lang:25:41:KEYWORD:END
     37. p1.lang:25:45:WORD:'drop'
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc main:
      0. IF
      1. PUSH_INT:1
      2. PUSH_INT:2
      3. INTRINSIC:EQ
      4. DO:8
      5. PUSH_INT:11
      6. PUSH_INT:2
      7. INTRINSIC:MUL
      8. ELSE:12
      9. PUSH_INT:12
     10. PUSH_INT:2
     11. INTRINSIC:MUL
     12. END:13
     13. INTRINSIC:PRINT
     14. PUSH_INT:10
     15. WHILE
     16. INTRINSIC:DUP
     17. PUSH_INT:5
     18. INTRINSIC:GT
     19. DO:24
     20. INTRINSIC:DUP
     21. INTRINSIC:PRINT
     22. PUSH_INT:1
     23. INTRINSIC:SUB
     24. END:15
     25. INTRINSIC:DROP
     26. PUSH_INT:10
     27. WHILE
     28. INTRINSIC:DUP
     29. PUSH_INT:5
     30. INTRINSIC:GT
     31. DO:36
     32. INTRINSIC:DUP
     33. INTRINSIC:PRINT
     34. PUSH_INT:1
     35. INTRINSIC:SUB
     36. END:27
     37. INTRINSIC:DROP
     38. RET
[TRACE] <?>:0:0: Generated C code:
[NOTE] generated_code:
    #include <stdio.h>
    #include <stdbool.h>
    typedef struct {
    } ret_main;
    ret_main proc_main() {
      int lit_int_0;
      int lit_int_1;
      int eq_0;
      int lit_int_2;
      int lit_int_3;
      int mul_0;
      int lit_int_4;
      int lit_int_5;
      int mul_1;
      int lit_int_6;
      int dup_0;
      int lit_int_7;
      int gt_0;
      int dup_1;
      int lit_int_8;
      int sub_0;
      int lit_int_9;
      int dup_2;
      int lit_int_10;
      int gt_1;
      int dup_3;
      int lit_int_11;
      int sub_1;
      lit_int_0 = 1;
      lit_int_1 = 2;
      eq_0 = lit_int_0 == lit_int_1;
      if (eq_0) {
        lit_int_2 = 11;
        lit_int_3 = 2;
        mul_0 = lit_int_2 * lit_int_3;
      } else {
        lit_int_4 = 12;
        lit_int_5 = 2;
        mul_1 = lit_int_4 * lit_int_5;
        mul_0 = mul_1;
      }
      printf("%d\n", mul_0);
      lit_int_6 = 10;
      while (true) {
        dup_0 = lit_int_6;
        lit_int_7 = 5;
        gt_0 = dup_0 > lit_int_7;
        if (gt_0) {
          dup_1 = lit_int_6;
          printf("%d\n", dup_1);
          lit_int_8 = 1;
          sub_0 = lit_int_6 - lit_int_8;
          lit_int_6 = sub_0;
        } else break;
      }
      lit_int_9 = 10;
      while (true) {
        dup_2 = lit_int_9;
        lit_int_10 = 5;
        gt_1 = dup_2 > lit_int_10;
        if (gt_1) {
          dup_3 = lit_int_9;
          printf("%d\n", dup_3);
          lit_int_11 = 1;
          sub_1 = lit_int_9 - lit_int_11;
          lit_int_9 = sub_1;
        } else break;
      }
      return (ret_main){
      };
    }
    int main() {
      proc_main();
      return 0;
    }
[CMD] gcc p1.lang.c -o p1.lang.out

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE build p2.lang
[STDOUT]:
[TRACE] <?>:0:0: file: p2.lang
[NOTE] Tokens:
      0. p2.lang:2:0:INT:1
      1. p2.lang:3:0:INT:2
      2. p2.lang:4:0:WORD:'swap'
      3. p2.lang:5:0:WORD:'dup'
      4. p2.lang:6:0:WORD:'print'
      5. p2.lang:7:0:INT:10
      6. p2.lang:8:0:WORD:'*'
      7. p2.lang:9:0:WORD:'+'
      8. p2.lang:10:0:KEYWORD:WHILE
      9. p2.lang:11:2:WORD:'dup'
     10. p2.lang:12:2:INT:3
     11. p2.lang:13:2:WORD:'>'
     12. p2.lang:14:0:KEYWORD:DO
     13. p2.lang:15:2:KEYWORD:IF
     14. p2.lang:16:4:WORD:'dup'
     15. p2.lang:17:4:INT:2
     16. p2.lang:18:4:WORD:'%'
     17. p2.lang:19:4:INT:0
     18. p2.lang:20:4:WORD:'=='
     19. p2.lang:21:2:KEYWORD:DO
     20. p2.lang:22:4:INT:5
     21. p2.lang:23:2:KEYWORD:ELSE
     22. p2.lang:24:4:INT:7
     23. p2.lang:25:2:KEYWORD:END
     24. p2.lang:27:2:WORD:'print'
     25. p2.lang:28:2:INT:1
     26. p2.lang:29:2:WORD:'-'
     27. p2.lang:30:0:KEYWORD:END
     28. p2.lang:32:0:WORD:'drop'
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc main:
      0. PUSH_INT:1
      1. PUSH_INT:2
      2. INTRINSIC:SWAP
      3. INTRINSIC:DUP
      4. INTRINSIC:PRINT
      5. PUSH_INT:10
      6. INTRINSIC:MUL
      7. INTRINSIC:ADD
      8. WHILE
      9. INTRINSIC:DUP
     10. PUSH_INT:3
     11. INTRINSIC:GT
     12. DO:27
     13. IF
     14. INTRINSIC:DUP
     15. PUSH_INT:2
     16. INTRINSIC:MOD
     17. PUSH_INT:0
     18. INTRINSIC:EQ
     19. DO:21
     20. PUSH_INT:5
     21. ELSE:23
     22. PUSH_INT:7
     23. END:24
     24. INTRINSIC:PRINT
     25. PUSH_INT:1
     26. INTRINSIC:SUB
     27. END:8
     28. INTRINSIC:DROP
     29. RET
[TRACE] <?>:0:0: Generated C code:
[NOTE] generated_code:
    #include <stdio.h>
    #include <stdbool.h>
    typedef struct {
    } ret_main;
    ret_main proc_main() {
      int lit_int_0;
      int lit_int_1;
      int dup_0;
      int lit_int_2;
      int mul_0;
      int add_0;
      int dup_1;
      int lit_int_3;
      int gt_0;
      int dup_2;
      int lit_int_4;
      int mod_0;
      int lit_int_5;
      int eq_0;
      int lit_int_6;
      int lit_int_7;
      int lit_int_8;
      int sub_0;
      lit_int_0 = 1;
      lit_int_1 = 2;
      dup_0 = lit_int_0;
      printf("%d\n", dup_0);
      lit_int_2 = 10;
      mul_0 = lit_int_0 * lit_int_2;
      add_0 = lit_int_1 + mul_0;
      while (true) {
        dup_1 = add_0;
        lit_int_3 = 3;
        gt_0 = dup_1 > lit_int_3;
        if (gt_0) {
          dup_2 = add_0;
          lit_int_4 = 2;
          mod_0 = dup_2 % lit_int_4;
          lit_int_5 = 0;
          eq_0 = mod_0 == lit_int_5;
          if (eq_0) {
            lit_int_6 = 5;
          } else {
            lit_int_7 = 7;
            lit_int_6 = lit_int_7;
          }
          printf("%d\n", lit_int_6);
          lit_int_8 = 1;
          sub_0 = add_0 - lit_int_8;
          add_0 = sub_0;
        } else break;
      }
      return (ret_main){
      };
    }
    int main() {
      proc_main();
      return 0;
    }
[CMD] gcc p2.lang.c -o p2.lang.out

[EXIT CODE] 0
============================================================
[CMD] py lang.py -l TRACE build procs.lang
[STDOUT]:
[TRACE] <?>:0:0: file: procs.lang
[NOTE] Tokens:
      0. procs.lang:1:0:KEYWORD:PROC
      1. procs.lang:1:5:WORD:'a'
      2. procs.lang:1:7:WORD:'int'
      3. procs.lang:1:11:KEYWORD:TYPE_DELIM
      4. procs.lang:1:14:WORD:'int'
      5. procs.lang:1:18:KEYWORD:DO
      6. procs.lang:2:4:WORD:'?'
      7. procs.lang:3:4:INT:2
      8. procs.lang:4:4:WORD:'?'
      9. procs.lang:5:4:WORD:'*'
     10. procs.lang:6:4:WORD:'?'
     11. procs.lang:7:0:KEYWORD:END
     12. procs.lang:9:0:KEYWORD:PROC
     13. procs.lang:9:5:WORD:'main'
     14. procs.lang:9:10:KEYWORD:TYPE_DELIM
     15. procs.lang:9:13:KEYWORD:DO
     16. procs.lang:10:4:WORD:'?'
     17. procs.lang:11:4:INT:5
     18. procs.lang:12:4:WORD:'?'
     19. procs.lang:13:4:WORD:'a'
     20. procs.lang:14:4:WORD:'?'
     21. procs.lang:15:4:WORD:'print'
     22. procs.lang:16:4:WORD:'?'
     23. procs.lang:17:0:KEYWORD:END
[TRACE] <?>:0:0: Compiled IR
[NOTE] IR:
    IR:
    proc a:
      0. INTRINSIC:DEBUG
      1. PUSH_INT:2
      2. INTRINSIC:DEBUG
      3. INTRINSIC:MUL
      4. INTRINSIC:DEBUG
      5. RET
    proc main:
      0. INTRINSIC:DEBUG
      1. PUSH_INT:5
      2. INTRINSIC:DEBUG
      3. WORD:'a'
      4. INTRINSIC:DEBUG
      5. INTRINSIC:PRINT
      6. INTRINSIC:DEBUG
      7. RET
[INFO] procs.lang:2:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
[INFO] procs.lang:4:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
      1. INT@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:5:4
[INFO] procs.lang:10:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:11:4
[INFO] procs.lang:14:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:13:4
[INFO] procs.lang:16:4: Stack at compile time:
[NOTE] stack: (empty)
[TRACE] <?>:0:0: Generated C code:
[NOTE] generated_code:
    #include <stdio.h>
    #include <stdbool.h>
    typedef struct {
      int _0;
    } ret_a;
    ret_a proc_a(int arg_0) {
      int lit_int_0;
      int mul_0;
      lit_int_0 = 2;
      mul_0 = arg_0 * lit_int_0;
      return (ret_a){
        ._0 = mul_0,
      };
    }
    typedef struct {
    } ret_main;
    ret_main proc_main() {
      int lit_int_1;
      int res_a_0_0;
      lit_int_1 = 5;
      ret_a res_a = proc_a(lit_int_1);
      res_a_0_0 = res_a._0;
      printf("%d\n", res_a_0_0);
      return (ret_main){
      };
    }
    int main() {
      proc_main();
      return 0;
    }
[CMD] gcc procs.lang.c -o procs.lang.out

[EXIT CODE] 0
============================================================
[CMD] py lang.py build -r p1.lang
[STDOUT]:
[CMD] gcc p1.lang.c -o p1.lang.out
[CMD] ./p1.lang.out
[STDOUT]:
24
10
9
8
7
6
10
9
8
7
6


[EXIT CODE] 0
============================================================
[CMD] py lang.py build -r p2.lang
[STDOUT]:
[CMD] gcc p2.lang.c -o p2.lang.out
[CMD] ./p2.lang.out
[STDOUT]:
1
5
7
5
7
5
7
5
7
5


[EXIT CODE] 0
============================================================
[CMD] py lang.py build -r procs.lang
[STDOUT]:
[INFO] procs.lang:2:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
[INFO] procs.lang:4:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
      1. INT@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:5:4
[INFO] procs.lang:10:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:11:4
[INFO] procs.lang:14:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:13:4
[INFO] procs.lang:16:4: Stack at compile time:
[NOTE] stack: (empty)
[CMD] gcc procs.lang.c -o procs.lang.out
[CMD] ./procs.lang.out
[STDOUT]:
10


[EXIT CODE] 0
============================================================
[CMD] py lang.py run p1.lang
[STDOUT]:
[PRINT] INT:24@p1.lang:10:7
[PRINT] INT:10@p1.lang:14:0
[PRINT] INT:9@p1.lang:19:4
[PRINT] INT:8@p1.lang:19:4
[PRINT] INT:7@p1.lang:19:4
[PRINT] INT:6@p1.lang:19:4
[PRINT] INT:10@p1.lang:25:0
[PRINT] INT:9@p1.lang:25:39
[PRINT] INT:8@p1.lang:25:39
[PRINT] INT:7@p1.lang:25:39
[PRINT] INT:6@p1.lang:25:39

[EXIT CODE] 0
============================================================
[CMD] py lang.py run p2.lang
[STDOUT]:
[PRINT] INT:1@p2.lang:2:0
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4
[PRINT] INT:7@p2.lang:24:4
[PRINT] INT:5@p2.lang:22:4

[EXIT CODE] 0
============================================================
[CMD] py lang.py run procs.lang
[STDOUT]:
[INFO] procs.lang:2:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
[INFO] procs.lang:4:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:1:7
      1. INT@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:5:4
[INFO] procs.lang:10:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:11:4
[INFO] procs.lang:14:4: Stack at compile time:
[NOTE] stack:
      0. INT@procs.lang:13:4
[INFO] procs.lang:16:4: Stack at compile time:
[NOTE] stack: (empty)
[INFO] procs.lang:10:4: Stack at runtime:
[NOTE] stack: (empty)
[INFO] procs.lang:12:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
[INFO] procs.lang:2:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
[INFO] procs.lang:4:4: Stack at runtime:
[NOTE] stack:
      0. INT:5@procs.lang:11:4
      1. INT:2@procs.lang:3:4
[INFO] procs.lang:6:4: Stack at runtime:
[NOTE] stack:
      0. INT:10@procs.lang:5:4
[INFO] procs.lang:14:4: Stack at runtime:
[NOTE] stack:
      0. INT:10@procs.lang:5:4
[PRINT] INT:10@procs.lang:5:4
[INFO] procs.lang:16:4: Stack at runtime:
[NOTE] stack: (empty)

[EXIT CODE] 0
